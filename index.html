<!doctype HTML>
<html>
<link rel="icon" href="data:;base64,iVBORw0KGgo=">
<script src="js/aframe.min.js"></script>
<script src="js/aframe-ar.js"></script>
<body style="margin: 0px; overflow: hidden;">

<script>

AFRAME.registerComponent('updater', {

	init: function()
	{
        // declare variable for later access
		this.num = 0;
        // you can also access the underlying 3D object of a scene object,
        //   for example:
		// let target = document.querySelector('#earth').object3D;
        // target.scale.set( 0.75, 0.75, 0.75 );
	},
	
    // time      = total time since init (milliseconds)
    // timeDelta = time since last tick
	tick: function (time, timeDelta) 
	{
		this.num += 1;
        // console.log( this.num );
	}
	
});

// access underlying 3D object this component is attached to
AFRAME.registerComponent('spinner', {

	init: function()
	{
		this.el.object3D.scale.set(1.5, 1.5, 1.5);
	},
	
	tick: function (time, timeDelta) 
	{
		//this.el.object3D.rotation.y += 0.01
	}
    
});

// Adjusted component to account for globe scaling
AFRAME.registerComponent('line-to-zurich', {
    schema: {
        target: {type: 'selector'},
        startPoint: {type: 'vec3'},
        endPoint: {type: 'vec3'},
        color: {type: 'color', default: '#FF0000'}
    },
    
    init: function() {
        let line = document.createElement('a-entity');
        line.setAttribute('line', `start: ${JSON.stringify(this.data.startPoint)}; end: ${JSON.stringify(this.data.endPoint)}; color: ${this.data.color}`);
        this.el.appendChild(line);
        this.line = line;
    },

    tick: function() {
        // let globeRotationY = this.data.target.object3D.rotation.y;
        // let radianOffset = globeRotationY; // Assuming Zurich's position offset in radians
        // let endPoint = this.calculateEndPoint(radianOffset);
        // this.line.setAttribute('line', `start: ${JSON.stringify(this.data.startPoint)}; end: ${endPoint.x} ${endPoint.y} ${endPoint.z}; color: ${this.data.color}`);
    },

    calculateEndPoint: function(rotationY) {
        // Adjust for the globe's scale
        let scale = 1.5;
        let radius = 0.5 * scale; // Adjusting radius for scale
        let x = radius * Math.sin(rotationY);
        let z = radius * Math.cos(rotationY) - (0.05 * scale); // Adjusting initial Z position for scale
        // Adjust Y position for scale, if necessary
        let y = 0.75 * scale;
        return {x: x, y: y, z: z};
    }
});


</script>


<a-scene embedded vr-mode-ui="enabled: false;" renderer="logarithmicDepthBuffer: true"arjs='sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;'>

    <a-assets>
		<img id="earth-sphere" src="images/earth-sphere.jpg" />
	</a-assets>
    
    <a-marker type="barcode" value="6">
        <a-sphere 
           id="earth"
           position="0 0.5 0"
           material="src: #earth-sphere; transparent: true; opacity: 0.95;"
           spinner >
        </a-sphere>

        <!-- Adding Irchel Campus text in red -->
        <a-text value="Irchel Campus"
            color="red"
            position="0 3 0"
            align="center"
            width="6">
        </a-text>

        <!-- Drawing a red line pointing to Zurich -->
        <a-entity line="start: 0 2.7 0; end: 1.004, 1.604, -0.151; color: red"></a-entity>
    </a-marker>
    
    <a-entity camera></a-entity>
    
    <!-- empty entity, running previously declared script -->
    <a-entity updater></a-entity>
    
    
    
</a-scene>
</body>
</html>